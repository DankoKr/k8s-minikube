### Node and Pod
- Node physical or VM
- Node contains Pods
Pod is the smallest unit
- Pod is abstraction over container
- Pod creates running env on top of the container
- Pod is meant to run 1 app
- Each Pod has an IP (can communicate with other Pods)

### Service (SVC) -> permanent IP that can be attached to Pod
- Provides stable IP for Pods
- Loadbalancing
- External -> for communication outside
- Internal -> inside but not outside

# ClusterIP service
- Default
- Internal service
- Accesible only inside the cluster

# NodePort
- Accessible on a static port on each Pod in the cluster
- Accessible outside the cluster
- Limit on port between 30000 and 32767 
- Not secure


### Ingress
- Used for DNS 
- Forwards requests to the Service (Pod IP)

### ConfigMap
- External configuration data (db connection url...)
- Not for sensitive data

### Secret
- Like ConfigMap but for sensitive data
- Stores data in base64 encoded
- Works as a Load Balancer

### Volumes
- Data storage
- Attaches a physical storage on a harddrive to a Pod
- Could store local in Node or outside the cluster
- Not namespaced (not part of one)


### Deployment
- Blueprint for Ports (for Pod replicas)
- Cant replicate DB (use StatefulSet)

### StatefulSet
- For Stateful apps (DBs)
- Takes care for DB synch

### K8s Architecture

# Worker machine
- Node whith Pods
- Uses most ressources
- 3 processes:
 -> container runtime
 -> kubelet (interacts whit the runtime and the Node)
 -> kube-proxy (controls communication between Nodes)

# Master Node
- 4 processes to controle the cluster states:
 -> API server (cluster gateway -> gets requests and acts as auth. Entry point for the cluster)
 -> Schedular (to start the Node and decided where to schedule Pods but the kublet starts it)
 -> Controller manager (detects a Node has died and reschedules by making a request to the Schedular)
 -> etcd (key value store that is distributed accross all Master Nodes, kluster brain, stores data for worker Nodes - ressources like CPU health..., DOES NOT STORE APP DATA)

# Minikube
- For local machine -> testing/learning
- 1 Node cluster (acts as a Master and a Worker)
- Creates Virtual Box to run the cluster
- Minikube CTL - to start/stop the cluster

# kubectl
- Interracts whith the cluster by contacting the API server
- For any type of clusre setup
- Used for configuring the Minikube cluster

 
### Main kubectl commands
- kubectl get nodes
- kubectl get pod
- kubectl get services
- kubectl create deployment NAME --image=image (name -> name of pod, image- image)
- kubectl get replicaset
- kubectl edit deployment DEPLOYMENT_NAME
- kubectl logs PODNAME
- kubectl describe pod POD_NAME
- kubectl exec -it PODNAME (gets the terminal of the container)
- kubectl delete deployment PODNAME
- kubectl apply -f FILE_NAME.yaml (used also to update a deployment)
- kubectl get all | grep NAME (get all items for a with a given name)
- minikube service SERVICE_NAME (start service that gives external access to cluster via browser)


# Layers of Abstraction:
-> Deployment manages Replicasets
-> Replicasets manages Pods
-> Pods is an abstraction of a Container


### K8s YAML
- 3 parts:
apiVersion and kind (Deployment/Service/....)
 -> metadata (name, labels)
 -> spec (replicas, selector, template)
 -> status (automaticly generated by K8s -> Desired? = Active) from etcd


- Store the yaml in the codebase or in additional repo

## Secret yaml CREATE BEFORE DEPLOYMENT
apiVersion: v1
kind: Secret
metadata:
    name: SECRET_NAME
type: Opaque (this is the defaukt one that uses key-value pairs)
data:
    username:...... (store it encoded and not as plain text)
    password:......

# To get an encoded str -> echo -n STRING | base64

## Internal Service yaml (include in the Pod yaml)
apiVersion: v1
kind: Service
metadata:
  name: SERVICE_NAME
spec:
  selector:
    app: POD_NAME
  ports:
    - protocol: TCP
      port: sERVICE_PORT
      targetPort: CONTAINER_PORT

## ConfigMap yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: CONGIFMAP_NAME
data:
  database_url: SERVICE_NAME_DB


## External Service yaml
apiVersion: v1
kind: Service
metadata:
  name: SERVICE_NAME
spec:
  selector:
    app: POD_NAME
  type: LoadBalancer
  ports:
    - protocol: TCP
      port: 8081
      targetPort: 8081
      nodePort: 30000  (to access it from browser - can be between 30000 - 32767)


### Namespace
- Virtual cluster inside a cluster
- Namespaces per default:
 -> kube-system (dont touch)
 -> kube-public (public accessible data with no auth needed)
 -> kube-node-lease  (info about the heartbeats of Nodes)
 -> default (all the custom ressources)

- kubectl create namespace NAME_NAMESPACE (do it in yaml instead)

- Namespaces work as groups for given ressources or staging/depl or app versions
- Limit ressources and/or access for the teams working on a cluster
- You cant access most of the ressources from another namespace
- Cant isolate in a namespaces -> volumes, persistance storage

- Create components in namespace -> by default it goes in default namespace or you should specify in the yaml
 

### Ingress
- IP address and port is not opened
- Ingress redirects the browser request to the internal service and from there to the Pod
- For https and a custom domain name
 
## Ingress Controller
- Validates the rules
- Entrypoint to cluster
- Manages redirections
- Third-party implementation that requires installation (K8s Nginx)


### Helm 
- Package Manager of K8s
- Templating Engine -> used for Deployment and Service configurations
 

### StatefulSet
- Used for Stateful apps (DBs)
- Manages the replication of Pods
- Replica Pods are not identical in Stateful apps
- Pod that updates the data is called Master (the rest are Slaves)
- Pods do not have access to the same physical storage data
- Deloyment gives a random hash for ID while Stateful - fixed ordered name:  STATEFULSET_NAME-ORDINAL (Ex: mysql-0)
- ALWAYS deletes the last replica
- Creates a new replica ONLY if the previous one is alive
- Each Pod has own DNS (Ex: mysql-0.svc2)
- Name and waypoint stays the same when Pod is changed



